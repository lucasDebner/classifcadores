# -*- coding: utf-8 -*-
"""
Modelo de Rede Neural Artificial para Classificação em 7 classes
Aluno: Lucas Debner da Silva
"""

# =====================================================================
# 1. UPLOAD DO ARQUIVO
# =====================================================================

from google.colab import files
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

uploaded = files.upload()  # Seleciona o insurance.csv
filename = list(uploaded.keys())[0]
df = pd.read_csv(filename)

print("\nArquivo carregado com sucesso!")
print(df.head())

# =====================================================================
# 2. PRÉ-PROCESSAMENTO
# =====================================================================

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.metrics import accuracy_score, classification_report, f1_score, confusion_matrix

# Convertendo variáveis categóricas
df['sex'] = df['sex'].map({'male': 0, 'female': 1})
df['smoker'] = df['smoker'].map({'no': 0, 'yes': 1})
df['region'] = df['region'].astype('category').cat.codes

# Criando 7 classes pelo custo do seguro (quantis)
df['charge_class'] = pd.qcut(df['charges'], q=7, labels=False)

# Seleção de variáveis
X = df[['age', 'bmi', 'children', 'sex', 'smoker', 'region']]
y = df['charge_class'].values.reshape(-1, 1)

# One-hot encoding da saída
encoder = OneHotEncoder(sparse_output=False)
y_encoded = encoder.fit_transform(y)

# Padronização
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Divisão treino/teste
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y_encoded, test_size=0.3, random_state=42
)

# =====================================================================
# 3. MODELO DE RNA
# =====================================================================

from keras.models import Sequential
from keras.layers import Dense
from keras.optimizers import Adam

def criar_modelo(num_camadas_ocultas=2, num_neuronios=12, taxa_aprendizado=0.01):
    modelo = Sequential()
    modelo.add(Dense(num_neuronios, input_dim=X.shape[1], activation='relu'))

    for _ in range(num_camadas_ocultas - 1):
        modelo.add(Dense(num_neuronios, activation='relu'))

    modelo.add(Dense(7, activation='softmax'))  # saída com 7 classes

    modelo.compile(
        loss='categorical_crossentropy',
        optimizer=Adam(learning_rate=taxa_aprendizado),
        metrics=['accuracy']
    )
    return modelo

modelo = criar_modelo()

# =====================================================================
# 4. TREINAMENTO
# =====================================================================

historico = modelo.fit(
    X_train, y_train,
    epochs=120,
    batch_size=8,
    verbose=0
)

# =====================================================================
# 5. AVALIAÇÃO
# =====================================================================

y_pred = modelo.predict(X_test)
y_pred_classes = np.argmax(y_pred, axis=1)
y_test_classes = np.argmax(y_test, axis=1)

accuracy = accuracy_score(y_test_classes, y_pred_classes)
f1 = f1_score(y_test_classes, y_pred_classes, average='weighted')

print("\nDesempenho da RNA:")
print(f"Acurácia: {accuracy:.3f}")
print(f"F1-Score Médio: {f1:.3f}")
print("\nRelatório de Classificação:\n",
      classification_report(y_test_classes, y_pred_classes))

# =====================================================================
# 6. GRÁFICOS DE TREINAMENTO
# =====================================================================

plt.figure(figsize=(12, 5))

# Perda
plt.subplot(1, 2, 1)
plt.plot(historico.history['loss'], label='Perda de Treinamento')
plt.title("Perda durante o Treinamento")
plt.xlabel("Épocas")
plt.ylabel("Loss")
plt.legend()

# Acurácia
plt.subplot(1, 2, 2)
plt.plot(historico.history['accuracy'], label='Acurácia de Treinamento')
plt.title("Acurácia durante o Treinamento")
plt.xlabel("Épocas")
plt.ylabel("Acurácia")
plt.legend()

plt.tight_layout()
plt.show()

# =====================================================================
# 7. MATRIZ DE CONFUSÃO
# =====================================================================

matriz = confusion_matrix(y_test_classes, y_pred_classes)

plt.figure(figsize=(8, 6))
sns.heatmap(
    matriz,
    annot=True,
    fmt='d',
    cmap='Blues',
    linewidths=.5
)

plt.title("Matriz de Confusão - RNA (7 classes)")
plt.xlabel("Classe Predita")
plt.ylabel("Classe Real")
plt.show()

# =====================================================================
# 8. VISUALIZAÇÃO DOS PESOS COM VALORES
# =====================================================================

def visualizar_pesos(modelo):
    for i, camada in enumerate(modelo.layers):
        pesos = camada.get_weights()

        if len(pesos) > 0:
            w = pesos[0]  # matriz de pesos
            plt.figure(figsize=(10, 4))
            plt.title(f"Pesos da Camada {i+1}")

            plt.imshow(w, aspect="auto", cmap="viridis")
            plt.colorbar(label="Valor do peso")

            for linha in range(w.shape[0]):
                for coluna in range(w.shape[1]):
                    valor = w[linha, coluna]
                    cor_texto = "white" if abs(valor) > np.max(np.abs(w)) * 0.5 else "black"
                    plt.text(
                        coluna,
                        linha,
                        f"{valor:.2f}",
                        ha="center",
                        va="center",
                        color=cor_texto,
                        fontsize=7
                    )

            plt.xlabel("Neurônios da Camada")
            plt.ylabel("Entradas / Features")
            plt.tight_layout()
            plt.show()

visualizar_pesos(modelo)

